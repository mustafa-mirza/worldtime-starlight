import json
import urllib3
import urllib
import os
import sys
import argparse
import time
import getpass
from datetime import datetime
import logging
from logging.handlers import RotatingFileHandler
import configparser
from urllib3.exceptions import NewConnectionError
#--------------------------------------------------------------------------------------------------------------------------------------------------
#Python version check
if sys.version_info < (3, 0):
    sys.stdout.write("Requires Python 3.x\n")
    sys.exit(1)

token_expire_time = 0
access_token_from_orch = ''

DATE_TIME_FORMAT = '%Y-%m-%d %H:%M:%S'

FILE_DATE_TIME_FORMAT = "%Y%m%d-%I%M%S"
LOG_FILE_PREFIX = "appVersionVulnerabilityCount_"
log_formatter = logging.Formatter('%(asctime)s %(levelname)s %(name)s %(message)s')

ORCHESTRATOR_API_GET_VULNERABILITIES="/api/application/vulnerabilities"

VULNERABILITY_TYPE_APPLICATION_VERSION = 'ApplicationVersion'
FIELD_CUSTNAME = "custName"
FIELD_DEPTNAME = "deptName"
FIELD_CUST_ID = "custId"
FIELD_DEPT_ID = "deptId"

parser = argparse.ArgumentParser(
 description='Gets count for Critial and High Appication version vulnerabilities.',
 epilog="Gets count for Critial and High Appication version vulnerabilities."
 )
parser.add_argument('--username', help='(Optional) Orchestrator user username')
parser.add_argument('--password', help='(Optional) Orchestrator user password')
parser.add_argument('--fromdate',
					help="(Mandatory) Filter out records from the date. Expected Date format is 'yyyy-mm-dd HH:MM:SS'.")
parser.add_argument('--todate',
					help="(Optional) Filter out records to date. Expected Date format is 'yyyy-mm-dd HH:MM:SS'.")
parser.add_argument('--domain', help='(Optional only if --inputFile option used) Filter out records with the domain name')
parser.add_argument('--subdomain', help='(Optional only if --inputFile option used) Filter out records with the subdomain name')

args = parser.parse_args()

class Arg:
	fromdate = args.fromdate
	if fromdate is None:
		print("argument --fromdate is missing")
		parser.print_help()
		exit()

	todate = args.todate

	startTimestamp = None
	endTimestamp = None
	try:
		timestamp = time.time()
		utcOffset = (datetime.fromtimestamp(timestamp) - datetime.utcfromtimestamp(
			timestamp)).total_seconds()

		if fromdate:
			startTimestamp = datetime.strptime(fromdate, DATE_TIME_FORMAT)
			startTimestamp = int(startTimestamp.timestamp() + utcOffset)
		else:
			print("argument --fromdate is missing")
			exit()

		if todate:
			endTimestamp = datetime.strptime(todate, DATE_TIME_FORMAT)
			endTimestamp = int(endTimestamp.timestamp() + utcOffset)

		if not endTimestamp:
			endTimestamp = int(timestamp + utcOffset)

	except ValueError as e:
		print("Error while parsing data : ", e)
		print(e)
		exit()

	domain = args.domain
	if domain is None:
		print("argument --domain is missing")
		parser.print_help()
		exit()

	subDomain = args.subdomain
	if subDomain is None:
		print("argument --subdomain is missing")
		parser.print_help()
		exit()


execution_date_time_str = datetime.now().strftime(FILE_DATE_TIME_FORMAT)

log_file = LOG_FILE_PREFIX + execution_date_time_str + ".log"

log_handler = RotatingFileHandler(log_file, mode='a', maxBytes=10 * 1024 * 1024,
								  backupCount=1, encoding=None, delay=0)
log_handler.setFormatter(log_formatter)
log_handler.setLevel(logging.DEBUG)
app_log = logging.getLogger()
app_log.setLevel(logging.DEBUG)
app_log.addHandler(log_handler)


def print_info(message):
	logging.info(message)


def print_error(message, e, data):
    logging.error(message)
    if e:
        logging.error(e)
    if data:
        logging.error(data)


def print_warning(message):
	logging.warning(message)

CONFIG_FILE_NAME = 'commonConfig.cnf'
common_file_locations = ["./", '../common/']
CONFIG_FILE = None

for config_path in common_file_locations:
	config_file_path = os.path.join(config_path, CONFIG_FILE_NAME)
	if os.path.exists(config_file_path):
		CONFIG_FILE = config_file_path
		break

if not CONFIG_FILE:
	print_error("Config file " +  CONFIG_FILE_NAME + " not found.", None, None)
	exit()

config = configparser.RawConfigParser()
config.read(CONFIG_FILE)
if not config.has_section('Orchestrator'):
    print_error("Invalid config file, Section 'Orchestrator' is not found in the config file.", None, None)
    exit()

if not config.has_option('Orchestrator', 'ORCH_URL'):
    print_error("ORCH_URL is not set, please set it in the config file.", None, None)
    exit()

if not config.has_option('Orchestrator', 'CA_FILE'):
    print_error("CA_FILE is not set, please set it in the config file.", None, None)
    exit()

ORCH_URL = config.get('Orchestrator', 'ORCH_URL')
ca_file_Path = config.get('Orchestrator', 'CA_FILE')

CA_FILE = None
ca_file_name = None

if not ca_file_Path:
	print_error("CA file not found. Please configure the 'CA_FILE' property in " + CONFIG_FILE_NAME, None, None)
	exit()

if os.path.exists(ca_file_Path):
	CA_FILE = ca_file_Path
else:
	print_warning("Configured CA file " + ca_file_Path + " not found. Searching for common locations.")
	ca_file_name = os.path.basename(ca_file_Path)

if not CA_FILE:
	for config_path in common_file_locations:
		config_file_path = os.path.join(config_path, ca_file_name)
		if os.path.exists(config_file_path):
			CA_FILE = config_file_path
			print_info("Using CA file at location " + CA_FILE)
			break

if not CA_FILE:
	print_error("CA file not found. Please configure the 'CA_FILE' property in " + CONFIG_FILE_NAME, None, None)
	exit()

USERNAME = None
if config.has_option('Orchestrator', 'USERNAME'):
    USERNAME = config.get('Orchestrator', 'USERNAME')

PASSWORD = None
if config.has_option('Orchestrator', 'PASSWORD'):
    PASSWORD = config.get('Orchestrator', 'PASSWORD')

http_pool_manager = urllib3.PoolManager(assert_hostname=False, ca_certs=CA_FILE)

def validate_and_get_username(username):
    # Validate Orchestrator user username argument
    if username is None:
        username = USERNAME
    if username is None or len(username.strip()) == 0:
        username = str(input("Enter Orchestrator username:"))
        if username is None or len(username.strip()) == 0:
            print("Invalid or empty Orchestrator username")
            validate_and_get_username(username)
    return username


def validate_and_get_password(password):
    # Validate Orchestrator user password argument
    if password is None:
        password = PASSWORD
    if password is None or len(password.strip()) == 0:
        password = getpass.getpass(prompt="Enter Orchestrator user password:")
        if password is None or len(password.strip()) == 0:
            print("Invalid or empty Orchestrator user password")
            validate_and_get_password(password)
    return password


username = validate_and_get_username(args.username)
password = validate_and_get_password(args.password)


def get_access_token_from_orch(username, password):
    # -----Getting access token from Orchestrator BEGIN-----
    print_info("Getting access token from orchestrator")
    oauth_url = ORCH_URL + "/oauth/token"

    headers = {}
    try:
        response = http_pool_manager.request('POST', oauth_url,
                         fields={"username":username,
                "password":password,
                "grant_type":'password'})
        if response.status == 200:
            response_str = response.data.decode("utf-8")
            return json.loads(response_str)
        elif response.status == 401 or response.status == 403:
            print_error("Invalid user credentials", None, None)
            exit()
        elif response.status == 400:
            print_error("Bad Request or Invalid user credentials", None, None)
            exit()
        else:
            print_error("Cannot get accessToken from Orchestrator", None, None)
            exit()
    except NewConnectionError as e:
        print_error("Cannot connect to Orchestrator", e, None)
        print(e)
        exit()


def get_access_token():
    seconds = int(round(time.time()))
    global access_token_from_orch
    global token_expire_time
    if seconds < token_expire_time:
        return access_token_from_orch
    else:
        token_response = get_access_token_from_orch(username, password)
        #token_response = json.loads(token_response)
        access_token_from_orch = token_response["access_token"]
        expires_in = token_response["access_token_expires_in"]
        seconds = int(round(time.time()))

        token_expire_time = seconds + expires_in - 10
        return access_token_from_orch


def get_customer_information(access_token, customer_name):
    # -----Getting customer information from Orchestrator BEGIN-----
    print_info("Getting Customer information from the Orchestrator")
    url_params = {'custName': customer_name}
    encoded_url_params = urllib.parse.urlencode(url_params)
    request_url = ORCH_URL + "/api/customer/views.ws?" + encoded_url_params
    headers = {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + access_token
    }
    try:
        response = http_pool_manager.request('GET', request_url, headers=headers)
        if response.status == 200:
            response_str = response.data.decode("utf-8")
            customer_response = json.loads(response_str)
            customers = customer_response["listCustomers"]
            if len(customers) > 0:
                customer_json = customers[0]
                return customer_json
            else:
                print_error("No Customer with the name " + customer_name + " found for user.", None, None)
                return None
        else:
            print_error("Error while getting customer details: " + response.data.decode("utf-8"), None, None)
            return None
    except NewConnectionError as e:
        print_error("Error occurred while getting Customer information from the Orchestrator: ", e, None)
        exit()


def get_department_information(access_token, department_name, customer_id):
    # -----Getting department information from Orchestrator BEGIN-----
    print_info("Getting Department information from the Orchestrator")
    url_params = {'custId': str(customer_id), 'deptName': department_name}
    encoded_url_params = urllib.parse.urlencode(url_params)
    request_url = ORCH_URL + "/api/department/views.ws?" + encoded_url_params

    headers = {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + access_token
    }
    try:
        response = http_pool_manager.request('GET', request_url, headers=headers)
        if response.status == 200:
            response_str = response.data.decode("utf-8")
            department_response = json.loads(response_str)
            departments = department_response["listDepartments"]
            if len(departments) > 0:
                department_json = departments[0]
                return department_json
            else:
                print_error("No Department with the name " + department_name + " found for user.", None, None)
                return None
        else:
            print_error("Error while getting Department details: " + response.data.decode("utf-8"), None, None)
            return None
    except NewConnectionError as e:
        print_error("Error occurred while getting Department information from the Orchestrator: ", e, None)
        exit()


def get_vulnerabilities(access_token, from_date, to_date, app_id, domain_id, subdomain_id,
	vulnerability_type,
	session_next_app_id_for_owasp,
	session_next_checksum_for_owasp,
	session_next_rule_id_for_owasp,
	session_batch_size_for_owasp,
	app_path_highlight_prefix,
	app_path_highlight_post_fix):
	print_info("Getting vulnerabilities information from the Orchestrator")
	url_params = {"fromDate": from_date * 1000,
				  "toDate": to_date * 1000,
				  "domainId": domain_id,
				  "subDomainId": subdomain_id,
				  "vulnerabilityType": vulnerability_type,
				  "verbose": False}
	if app_id:
		url_params["appId"] = app_id

	if session_next_app_id_for_owasp :
		url_params["sessionNextAppIdForOwasp"] = session_next_app_id_for_owasp

	if session_next_checksum_for_owasp:
		url_params["sessionNextChecksumForOwasp"] = session_next_checksum_for_owasp

	if session_next_rule_id_for_owasp:
		url_params["sessionNextRuleIdForOwasp"] = session_next_rule_id_for_owasp

	if session_batch_size_for_owasp:
		url_params["sessionBatchSizeForOwasp"] = session_batch_size_for_owasp

	if app_path_highlight_prefix:
		url_params["appPathHighlightPrefix"] = app_path_highlight_prefix

	if app_path_highlight_post_fix:
		url_params["appPathHighlightPostFix"] = app_path_highlight_post_fix

	encoded_url_params = urllib.parse.urlencode(url_params)
	params = "?" + encoded_url_params

	request_url = ORCH_URL + ORCHESTRATOR_API_GET_VULNERABILITIES + params
	headers = {
		'Content-Type': 'application/json',
		'Authorization': 'Bearer ' + access_token
	}
	try:
		response = http_pool_manager.request('GET', request_url, headers=headers)
		if response.status == 200:
			response_str = response.data.decode("utf-8")
			json_response = json.loads(response_str)
			if len(json_response) > 0:
				return json_response
		else:
			print_error("Error while getting vulnerabilities: " + response.text)
			return None
	except requests.exceptions.RequestException as e:
		print_error("Error occurred while fetching vulnerabilities details from the Orchestrator: ", e, None)
		exit()
		
		
def execute():
	customer_json = get_customer_information(get_access_token(), Arg.domain)
	if customer_json is None:
		print_warning("Domain " + Arg.domain + " not found for the user")
		return None

	domain_id = customer_json[FIELD_CUST_ID]

	department_json = get_department_information(get_access_token(), Arg.subDomain, domain_id)
	if department_json is None:
		print_warning("Subdomain  " + Arg.subDomain + " with domain " + Arg.domain + " not found for the user")
		return None

	subdomain_id = department_json[FIELD_DEPT_ID]
	json_response = get_vulnerabilities(get_access_token(), Arg.startTimestamp, Arg.endTimestamp, None, domain_id, subdomain_id,
	VULNERABILITY_TYPE_APPLICATION_VERSION,
	None,
	None,
	None,
	0,
	None,
	None)

	data_list = json_response["dataList"]

	critical_count = 0
	high_count = 0
	medium_count = 0
	low_count = 0
	for data in data_list:
		severity = data["severity"]
		#print(severity)	
		if severity.lower() == 'critical':
			critical_count = critical_count + 1
		elif severity.lower() == 'high':
			high_count = high_count + 1
		elif severity.lower() == 'medium':
			medium_count = medium_count + 1
		else:
			low_count = low_count + 1
	
	print_info("Total Critical vulnerabilities:" + str(critical_count))
	print_info("Total High vulnerabilities:" + str(high_count))
	print_info("Total Medium vulnerabilities:" + str(medium_count))
	print_info("Total Low vulnerabilities:" + str(low_count))
		
	print(critical_count + high_count)


def main():
	execute()


#---START-------------------------------------------------------------------------------------------------------------
main()	
